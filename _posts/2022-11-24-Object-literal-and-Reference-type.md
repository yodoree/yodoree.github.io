---
layout: post
title: 모던 자바스크립트 Deep Dive
subtitle: 10~11장
author: yodoree
categories: TIL
tags: javascript
sidebar: []
---

어제 공부를 못했다.  
가족 모임이 있어 공부를 하지 못했다.  
사실 할 수 있었지만 가족모임을 핑계로 도피했다. 그래도 하루만 도피해서 다행이다.

# 객체 리터럴과 원시값과 객체의 비교

자바스크립트에서 가장 중요한 객체의 관한 내용이다.  
자바스크립트를 구성하는 거의 모든 것이 객체이다.(원시값 제외)

## 10장 객체 리터럴

객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키(key)와 값(value)으로 구성된다.
또 함수도 프로퍼티값으로 사용할 수 있는데 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메서드라고 부른다.  
따라서 객체는 프로퍼티와 메서드로 구성된 집합체이다.

- 프로퍼티: 객체의 상태를 나타내는 값(data)
- 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)

### 객체를 생성하는 방법

자바스크립트에서는 객체를 생성하는 다양한 방법이 있는데 가장 직관적이고 쉬운 방법이 **객체 리터럴**이다.  
리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법을 말한다.

### 프로퍼티 키

프로퍼티의 키에는 일반적으로 문자열을 사용한다.  
식별자 네이밍 규칙을 준수하는 이름, 즉 자바스크립트에서 사용 가능한 유효한 이름인 경우 따옴표를 생략할 수 있다.  
즉 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.

```javascript
var person = {
  firstName: "yohan",
  "last-name": "Kim",
};
```

이렇게 작성하는 것보다 식별자 네이밍 규칙을 따르는 것이 편하다.

프로퍼티 키에 문자열이나 심벌 값 외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다.

```javascript
var foo = {
  0: 1,
  1: 2,
  2: 3,
};

console.log(foo); // {0: 1, 1: 2, 2: 3}
```

### 프로퍼티 접근

존재하지 않는 프로퍼티에 접근하면 undefined를 반환하고 ReferenceError가 발생하지 않는다.

프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름, 즉 자바스크립트에서 사용 가능한 유요한 이름이 아니면 반드시 대괄호 표기법을 사용해야 한다.  
단, 프로퍼티 키가 숫자로 이뤄진 문자열인 경우 따옴표를 생략할 수 있다.  
그 외의 경우 대괄호 내에 들어가는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다는 점을 잊지 말자.

```javascript
var person = {
  'last-name': 'Kim'
  1: 10
}

person.'last-name'; // SyntaxError: Unexpected string
person.last-name; // 브라우저 환경: NaN, Node.js환경: ReferenceError: name in not defined
person[last-name]; //  ReferenceError: last in not defined
person['last-name']; // 'Kim'

person.1; // SyntaxError: Unexpected number
person.'1' // SyntaxError: Unexpected string
person[1]; // 10
person['1'] // 10
```

### 계산된 프로퍼티 이름

문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수도 있다.  
단, 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다.

```javascript
// ES5
var prefix = "prop";
var i = 0;

var obj = {};

obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;

console.log(obj); // {prop-1: 1, prop-2::2, prop-3: 3}

// ES6

const prefix = "prop";
let i = 0;

const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
};

console.log(obj); // {prop-1: 1, prop-2::2, prop-3: 3}
```

## 원시 값과 객체의 비교

원시 값은 변경이 불가능하다.  
이는 변수 값을 변경할 수 없다는 것이아니라 원시 값 자체를 변경할 수 없다는 것이다.

### 원시 타입별 메모리 공간의 크기

ECMAScript 사양에 문자열 타입(2바이트)과 수자 타입(8바이트) 이외의 원시 타입은 크기를 명확히 규정하고 있지는 않아서 브라우저 제조사의 구현에 따라 원시 타입의 크기는 다를 수 있다.
문자열은 단순하게 계산하면 1개의 문자로 이뤄진 문자열은 2바이트, 10개의 문자로 이뤄진 문장ㄹ은 20ㅂ이트가 필요하고, 숫자는 어떤 값도 동일한 8바이트가 필요하다.

### 유사 배열 객체

자바스크립트의 문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖기 때문에 유사 배열 객체이고 for 문으로 순회할 수도 있다.
하지만 문자열은 원시 값이므로 실제 배열처럼 값을 변경할 수는 없다.

### 얕은 복사와 깊은 복사

객체를 프로퍼티 값으로 갖는 객체의 경우 얕은 복사는 한 단계까지만 복사하는 것을 말하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말한다.

```javascript
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o };
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

// lodash의 cloneDeep을 사용한 깊은 복사

const c2 = _.cloneDeep(o);
console.log(c2 === o); /// false
console.log(c2.x === o.x); /// false
```

얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체다.  
즉, 원본과 복사본은 참조 값이 다른 별개의 객체다.

### 값, 참조에 의한 전달

원시 값은 값을 복사하면 새로운 메모리를 차지해 값을 복사해 저장하고 일치 비교를 해보면 true를 보여준다.  
객체는 복사하면 같은 메모리 공간을 참조해 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받고 일치 비교를 해보면 true를 보여준다.  
그런데 같은 내용으로 2개의 객체를 만들면 다른 메모리에 저장된 별개의 객체라서 일치 비교시 false를 보여준다. 그러면 원시 값을 복사했을때도 내용은 같지만 메모리는 다른데 왜 true가 나오는 것일까..?

---
layout: post
title: 모던 자바스크립트 Deep Dive
subtitle: 7장~9장
author: yodoree
categories: TIL
tags: javascript
sidebar: []
---

# 연산자와 제어문 그리고 타입 변환과 단축 평가

오늘은 연산자와 제어문이다.  
기존에 알고 있던 것보다 좀 더 정확하게 알게 된 것과 잘 이해 안가는 것들을 정리해 보고자 한다.

## 7장 연산자

### 연산자로 타입을 변환하는 것

이건 알고는 있었지만 자주 사용하는 방법은 아니였다.  
자바스크립트는 연산자로 피연산자를 연결하면 연산자에 따라 타입을 변환 시켜서 값을 만들어준다.  
그동안 표준 빌트인 생성자 함수(`parseInt`, `String`, 등등)를 통해 변환해 왔었다.

### 동등 비교와 일치 비교

`==` **동등 비교**, `===` **일치 비교**  
막연히 일치 비교가 좀 더 명확하게 비교해 주는 것이기 때문에 사용했는데 동등 비교는 **암묵적 타입 변환**을 통해 타입을 일치시킨 후 같은 값인지 비교하기 때문에 결과를 예측하기 어렵다.
따라서 **일치 비교** 연산자를 사용하는 것이 좋다.

### 삼항 조건 연산자

자주 사용 하긴 했으나 `if...else`문과 정확히 어떤 차이가 있는지 알지 못했다.  
삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식이라 다른 변수에 할당할 수도 있고 값을 결정할때 사용할 수 있다.  
`if...else`문은 값으로 사용할 수 없다.

### 연산자의 우선 순위

연산자의 우선순위가 있다.  
다양하게 있지만 이를 외우고 사용하기는 어려우니 가장 최우선 순위인 `()`괄호를 사용해서 연산을 하면 우선 순위 정하기가 편하다.

## 8장 제어문

### 레이블 문

레이블 문이란 식별자가 붙은 문을 말한다.

```javascript
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    if (i + j === 3) break outer;
    console.log(`inner[#${i}, ${j}]`);
  }
}
```

기존에 `break`문을 사용하면 해당 `for`문만 탈출하지만 레이블문을 사용하면 외부의 `for`문도 탈출할 수 있다.

### continue 문

`continue`문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반목문의 증감식으로 실행 흐름을 이동시킨다.

## 9장 타입 변환과 단축 평가

이 장은 알고는 있었으나 이런 명확한 개념단어들은 알지 못했다.

### 개발자의 의도에 의해 타입 변환

- 명시적 타입 변화
- 타입 캐스팅

### 타입이 자동으로 변환되는 것

- 암묵적 타입 변환
- 타입 강제 변환

### 명시적 vs 암묵적 타입 변환

서로 장단점이 있지만 코드를 예측할 수 있게 선택해서 작성하는 것이 좋다.

### 논리 연산자를 사용한 단축 평가

논리합(`||`) 이나 논리곱(`&&`) 연산자 표현식의 평가 결과는 Boolean값이 아닐 수도 있다. 이 두가지 연산자 표현식은 언제나 2개의 피연산자 중어느 한쪽으로 평가된다.

```javascript
"Cat" || "Dog"; // -> 'Cat'
false || "Dog"; // -> 'Dog'
"Cat" || false; // -> 'Cat'

"Cat" && "Dog"; // -> 'Dog'
false && "Dog"; // -> false
"Cat" && false; // -> false
```

따라서 조건이 false인 값일때 무언가 할려면 논리합(`||`), 조건이 true인 값일때 무언가 할려면 논리곱(`&&`)을 사용해 if문을 대체할 수 있다.

```javascript
var done = true;
var message = "";

if (done) message = "완료";

message = done && "완료";

var done = false;
var message = "";

if (!done) message = "미완료";

message = done || "미완료";
```

### 옵셔널 체이닝 연산자 `?.`

ES11이 나온지도 몰랐을 정도로 자바스크립트 공부를 하지 않았다.. 이번 기회에 반성하며 공부해보자.

ES11에서 도입된 `?.` 연산자는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고, 그렇지 않으면 웋ㅇ의 프로퍼티 참조를 이어간다.

```javascript
var elem = null;

var value = elem?.value;
console.log(value); // undefined

var value = elem && elem.value;
console.log(value); // null
```

### null 병합 연산자 `??`

마찬가지로 ES11에서 도입된 `??` 연산자는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그러지 않으면 좌항의 피연산자를 반환한다.

```javascript
var foo = null ?? "default string";
console.log(foo); // "default string"
```

기존의 논리 연산자 `||`를 사용한 단축 평가의 경우 좌항의 피연산자가 false로 평가되는 값(fasle, undefined, null, 0, -0, NaN, '')이면 우항의 피연산자를 반환하는데 0이나 ''도 값으로서 사용할 수 있기때문에 문제가 될 수 있다.  
이를 대체하기 위해 null 또는 undefined일때만 우항의 피연산자를 반환하는 **null 병합 연산자`??`**를 만들지 않았을까 생각한다.
